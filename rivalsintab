-- WA Universal ESP with Chams, Skeletons & Aimbot (NO UI - MOUSE METHOD)
-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- Drawing Cache
local ESP_Cache = {}
local ChamsCache = {}

-- ============================================
-- YOUR EXISTING ESP SETTINGS
-- ============================================
local Settings = {
    -- Main Settings
    Enabled = true,
    TeamCheck = false,
    ShowTeam = false,
    MaxDistance = 1000,
    
    -- Box ESP
    BoxESP = true,
    BoxStyle = "Full",
    BoxThickness = 3.2,
    
    -- Name ESP
    NameESP = true,
    TextSize = 14,
    
    -- Health ESP
    HealthESP = false,
    HealthStyle = "Bar",
    
    -- Tracer ESP
    TracerESP = false,
    TracerOrigin = "Bottom",
    
    -- Skeleton ESP
    SkeletonESP = true,
    SkeletonThickness = 8,
    
    -- Chams ESP
    ChamsESP = false,
    ChamsTransparency = 0.47,
    
    -- Rainbow
    RainbowEnabled = false,
    RainbowSpeed = 1,
    
    -- Colors
    EnemyColor = Color3.fromRGB(252, 255, 0),    -- #fcff00 (yellow)
    AllyColor = Color3.fromRGB(25, 255, 25),     -- #19ff19 (green)
    HealthColor = Color3.fromRGB(0, 255, 0),      -- #00ff00 (green)
    SkeletonColor = Color3.fromRGB(188, 0, 255),  -- #bc00ff (purple)
    ChamsColor = Color3.fromRGB(220, 0, 255),     -- #dc00ff (magenta)
}

-- ============================================
-- AIMBOT SETTINGS - ADJUST THESE
-- ============================================
local AimbotSettings = {
    Enabled = true,                    -- Master toggle
    Key = Enum.UserInputType.MouseButton2, -- MouseButton2 = right click
    TeamCheck = false,                  -- Don't aim at teammates
    LockPart = "Head",                   -- "Head", "Torso", "HumanoidRootPart"
    FOV = 180,                          -- Detection range (pixels)
    Smoothness = 0.3,                    -- 0 = instant, 1 = very slow/smooth
    Prediction = 0.2,                    -- Lead targets (0 = no prediction)
    ShowFOVCircle = true,                -- Show the FOV circle
    FOVCircleColor = Color3.fromRGB(255, 255, 0), -- Yellow
}

-- Colors table for dynamic updates
local Colors = {
    Enemy = Settings.EnemyColor,
    Ally = Settings.AllyColor,
    Health = Settings.HealthColor,
    Skeleton = Settings.SkeletonColor,
    Chams = Settings.ChamsColor,
    Rainbow = nil
}

-- ========== AIMBOT SYSTEM ==========
local Aimbot = {
    Active = false,
    Target = nil,
    FOVCircle = Drawing.new("Circle")
}

-- Setup FOV circle
Aimbot.FOVCircle.Visible = AimbotSettings.ShowFOVCircle and AimbotSettings.Enabled
Aimbot.FOVCircle.Thickness = 1
Aimbot.FOVCircle.NumSides = 60
Aimbot.FOVCircle.Color = AimbotSettings.FOVCircleColor
Aimbot.FOVCircle.Transparency = 0.5
Aimbot.FOVCircle.Radius = AimbotSettings.FOV

-- Find closest target within FOV
local function FindClosestTarget()
    local closestTarget = nil
    local shortestDistance = AimbotSettings.FOV
    local mousePos = UserInputService:GetMouseLocation()
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            -- Team check
            if AimbotSettings.TeamCheck and player.Team == LocalPlayer.Team then
                continue
            end
            
            local character = player.Character
            if not character then continue end
            
            local targetPart = character:FindFirstChild(AimbotSettings.LockPart) or character:FindFirstChild("HumanoidRootPart")
            if not targetPart then continue end
            
            local humanoid = character:FindFirstChild("Humanoid")
            if not humanoid or humanoid.Health <= 0 then continue end
            
            -- Get screen position
            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
            if not onScreen then continue end
            
            -- Calculate distance from mouse to target
            local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
            
            if distance < shortestDistance then
                shortestDistance = distance
                closestTarget = player
            end
        end
    end
    
    return closestTarget
end

-- Mouse movement aimbot (more reliable than CFrame manipulation)
local function MoveMouseToTarget(targetPos)
    local screenPos = Camera:WorldToViewportPoint(targetPos)
    local mousePos = UserInputService:GetMouseLocation()
    
    -- Calculate movement needed
    local dx = screenPos.X - mousePos.X
    local dy = screenPos.Y - mousePos.Y
    
    -- Apply prediction if enabled
    if AimbotSettings.Prediction > 0 then
        -- Simple prediction based on target velocity
        -- You can make this more sophisticated if needed
        dx = dx * (1 + AimbotSettings.Prediction)
        dy = dy * (1 + AimbotSettings.Prediction)
    end
    
    -- Apply smoothness
    if AimbotSettings.Smoothness > 0 then
        dx = dx * (1 - AimbotSettings.Smoothness)
        dy = dy * (1 - AimbotSettings.Smoothness)
    end
    
    -- Move mouse (using mousemoverel which is often undetected)
    if math.abs(dx) > 0.5 or math.abs(dy) > 0.5 then
        mousemoverel(dx, dy)
    end
end

-- Input handling
UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == AimbotSettings.Key and AimbotSettings.Enabled then
        Aimbot.Active = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == AimbotSettings.Key then
        Aimbot.Active = false
        Aimbot.Target = nil
    end
end)

-- Main aimbot loop
RunService.RenderStepped:Connect(function()
    -- Update FOV circle
    if AimbotSettings.Enabled and AimbotSettings.ShowFOVCircle then
        Aimbot.FOVCircle.Visible = true
        Aimbot.FOVCircle.Position = UserInputService:GetMouseLocation()
        Aimbot.FOVCircle.Radius = AimbotSettings.FOV
        Aimbot.FOVCircle.Color = Aimbot.Target and Color3.fromRGB(255, 0, 0) or AimbotSettings.FOVCircleColor
    else
        Aimbot.FOVCircle.Visible = false
    end
    
    -- Aimbot logic
    if AimbotSettings.Enabled and Aimbot.Active then
        Aimbot.Target = FindClosestTarget()
        
        if Aimbot.Target then
            local character = Aimbot.Target.Character
            if character then
                local targetPart = character:FindFirstChild(AimbotSettings.LockPart) or character:FindFirstChild("HumanoidRootPart")
                if targetPart then
                    MoveMouseToTarget(targetPart.Position)
                end
            end
        end
    end
end)
-- ========== END AIMBOT ==========

-- ESP Functions (unchanged from your working version)
local function GetPlayerColor(player)
    if Settings.RainbowEnabled and Colors.Rainbow then
        return Colors.Rainbow
    end
    return (Settings.TeamCheck and player.Team == LocalPlayer.Team) and Colors.Ally or Colors.Enemy
end

local function GetTracerOrigin()
    if Settings.TracerOrigin == "Bottom" then
        return Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
    elseif Settings.TracerOrigin == "Top" then
        return Vector2.new(Camera.ViewportSize.X/2, 0)
    elseif Settings.TracerOrigin == "Mouse" then
        return UserInputService:GetMouseLocation()
    else
        return Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    end
end

-- Skeleton Drawing
local function DrawSkeleton(character, skeletonDrawings, color, thickness)
    if not character then return end
    
    local bones = {
        {"Head", "UpperTorso"}, {"UpperTorso", "LowerTorso"},
        {"UpperTorso", "LeftUpperArm"}, {"LeftUpperArm", "LeftLowerArm"}, {"LeftLowerArm", "LeftHand"},
        {"UpperTorso", "RightUpperArm"}, {"RightUpperArm", "RightLowerArm"}, {"RightLowerArm", "RightHand"},
        {"LowerTorso", "LeftUpperLeg"}, {"LeftUpperLeg", "LeftLowerLeg"}, {"LeftLowerLeg", "LeftFoot"},
        {"LowerTorso", "RightUpperLeg"}, {"RightUpperLeg", "RightLowerLeg"}, {"RightLowerLeg", "RightFoot"}
    }
    
    local r6Fallback = {
        Head = "Head", UpperTorso = "Torso", LowerTorso = "Torso",
        LeftUpperArm = "Left Arm", LeftLowerArm = "Left Arm", LeftHand = "Left Arm",
        RightUpperArm = "Right Arm", RightLowerArm = "Right Arm", RightHand = "Right Arm",
        LeftUpperLeg = "Left Leg", LeftLowerLeg = "Left Leg", LeftFoot = "Left Leg",
        RightUpperLeg = "Right Leg", RightLowerLeg = "Right Leg", RightFoot = "Right Leg"
    }
    
    for i, connection in ipairs(bones) do
        local part1 = character:FindFirstChild(connection[1]) or character:FindFirstChild(r6Fallback[connection[1]])
        local part2 = character:FindFirstChild(connection[2]) or character:FindFirstChild(r6Fallback[connection[2]])
        
        if part1 and part2 then
            local screen1 = Camera:WorldToViewportPoint(part1.Position)
            local screen2 = Camera:WorldToViewportPoint(part2.Position)
            
            if screen1.Z > 0 and screen2.Z > 0 then
                if not skeletonDrawings[i] then
                    skeletonDrawings[i] = Drawing.new("Line")
                end
                skeletonDrawings[i].From = Vector2.new(screen1.X, screen1.Y)
                skeletonDrawings[i].To = Vector2.new(screen2.X, screen2.Y)
                skeletonDrawings[i].Color = color
                skeletonDrawings[i].Thickness = thickness
                skeletonDrawings[i].Visible = true
            elseif skeletonDrawings[i] then
                skeletonDrawings[i].Visible = false
            end
        elseif skeletonDrawings[i] then
            skeletonDrawings[i].Visible = false
        end
    end
end

local function CreateESP(player)
    if player == LocalPlayer then return end
    
    local objects = {
        Box = {
            Top = Drawing.new("Line"), Bottom = Drawing.new("Line"),
            Left = Drawing.new("Line"), Right = Drawing.new("Line"),
            TopLeft = Drawing.new("Line"), TopRight = Drawing.new("Line"),
            BottomLeft = Drawing.new("Line"), BottomRight = Drawing.new("Line")
        },
        Name = Drawing.new("Text"),
        Tracer = Drawing.new("Line"),
        HealthBar = {
            Outline = Drawing.new("Square"),
            Fill = Drawing.new("Square"),
            Text = Drawing.new("Text")
        },
        Skeleton = {}
    }
    
    for _, line in pairs(objects.Box) do
        line.Visible = false
        line.Color = Colors.Enemy
        line.Thickness = Settings.BoxThickness
    end
    
    objects.Name.Visible = false
    objects.Name.Center = true
    objects.Name.Outline = true
    objects.Name.Size = Settings.TextSize
    objects.Name.Color = Colors.Enemy
    objects.Name.Font = 2
    
    objects.Tracer.Visible = false
    objects.Tracer.Color = Colors.Enemy
    objects.Tracer.Thickness = 1
    
    objects.HealthBar.Outline.Visible = false
    objects.HealthBar.Outline.Filled = false
    objects.HealthBar.Outline.Color = Color3.new(0, 0, 0)
    objects.HealthBar.Outline.Thickness = 1
    
    objects.HealthBar.Fill.Visible = false
    objects.HealthBar.Fill.Filled = true
    objects.HealthBar.Fill.Color = Colors.Health
    
    objects.HealthBar.Text.Visible = false
    objects.HealthBar.Text.Center = true
    objects.HealthBar.Text.Size = Settings.TextSize
    objects.HealthBar.Text.Font = 2
    
    ESP_Cache[player] = objects
    
    -- Create chams highlight
    local highlight = Instance.new("Highlight")
    highlight.Name = "Chams_" .. player.Name
    highlight.FillColor = Colors.Chams
    highlight.FillTransparency = Settings.ChamsTransparency
    highlight.OutlineTransparency = 1
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Enabled = false
    ChamsCache[player] = highlight
end

local function RemoveESP(player)
    if ESP_Cache[player] then
        for _, obj in pairs(ESP_Cache[player]) do
            if type(obj) == "table" then
                for _, subObj in pairs(obj) do
                    pcall(function() subObj:Remove() end)
                end
            else
                pcall(function() obj:Remove() end)
            end
        end
        ESP_Cache[player] = nil
    end
    
    if ChamsCache[player] then
        pcall(function() ChamsCache[player]:Destroy() end)
        ChamsCache[player] = nil
    end
end

local function UpdateESP(player)
    if not Settings.Enabled then return end
    
    local objects = ESP_Cache[player]
    if not objects then
        CreateESP(player)
        objects = ESP_Cache[player]
    end
    if not objects then return end
    
    local character = player.Character
    if not character then
        for _, line in pairs(objects.Box) do line.Visible = false end
        if objects.Name then objects.Name.Visible = false end
        if objects.Tracer then objects.Tracer.Visible = false end
        for _, obj in pairs(objects.HealthBar) do obj.Visible = false end
        for _, line in pairs(objects.Skeleton) do if line then line.Visible = false end end
        return
    end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Torso")
    local humanoid = character:FindFirstChild("Humanoid")
    
    if not rootPart or not humanoid or humanoid.Health <= 0 then
        for _, line in pairs(objects.Box) do line.Visible = false end
        if objects.Name then objects.Name.Visible = false end
        if objects.Tracer then objects.Tracer.Visible = false end
        for _, obj in pairs(objects.HealthBar) do obj.Visible = false end
        for _, line in pairs(objects.Skeleton) do if line then line.Visible = false end end
        return
    end
    
    local pos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
    local distance = (rootPart.Position - Camera.CFrame.Position).Magnitude
    
    if not onScreen or distance > Settings.MaxDistance then
        for _, line in pairs(objects.Box) do line.Visible = false end
        if objects.Name then objects.Name.Visible = false end
        if objects.Tracer then objects.Tracer.Visible = false end
        for _, obj in pairs(objects.HealthBar) do obj.Visible = false end
        for _, line in pairs(objects.Skeleton) do if line then line.Visible = false end end
        return
    end
    
    local isTeam = Settings.TeamCheck and player.Team == LocalPlayer.Team
    if isTeam and not Settings.ShowTeam then
        for _, line in pairs(objects.Box) do line.Visible = false end
        if objects.Name then objects.Name.Visible = false end
        if objects.Tracer then objects.Tracer.Visible = false end
        for _, obj in pairs(objects.HealthBar) do obj.Visible = false end
        for _, line in pairs(objects.Skeleton) do if line then line.Visible = false end end
        return
    end
    
    local color = GetPlayerColor(player)
    
    -- Box calculations
    local size = character:GetExtentsSize()
    local cf = rootPart.CFrame
    local top = Camera:WorldToViewportPoint(cf * CFrame.new(0, size.Y/2, 0).Position)
    local bottom = Camera:WorldToViewportPoint(cf * CFrame.new(0, -size.Y/2, 0).Position)
    
    local screenHeight = math.abs(bottom.Y - top.Y)
    local boxWidth = screenHeight * 0.65
    local boxPos = Vector2.new(top.X - boxWidth/2, top.Y)
    local boxSize = Vector2.new(boxWidth, screenHeight)
    
    -- Box ESP
    if Settings.BoxESP then
        for _, line in pairs(objects.Box) do line.Visible = false end
        
        if Settings.BoxStyle == "Full" then
            if objects.Box.Left then
                objects.Box.Left.From = boxPos
                objects.Box.Left.To = boxPos + Vector2.new(0, boxSize.Y)
                objects.Box.Left.Visible = true
            end
            if objects.Box.Right then
                objects.Box.Right.From = boxPos + Vector2.new(boxSize.X, 0)
                objects.Box.Right.To = boxPos + Vector2.new(boxSize.X, boxSize.Y)
                objects.Box.Right.Visible = true
            end
            if objects.Box.Top then
                objects.Box.Top.From = boxPos
                objects.Box.Top.To = boxPos + Vector2.new(boxSize.X, 0)
                objects.Box.Top.Visible = true
            end
            if objects.Box.Bottom then
                objects.Box.Bottom.From = boxPos + Vector2.new(0, boxSize.Y)
                objects.Box.Bottom.To = boxPos + Vector2.new(boxSize.X, boxSize.Y)
                objects.Box.Bottom.Visible = true
            end
        else -- Corner
            local cornerSize = math.min(boxWidth * 0.2, 20)
            
            if objects.Box.TopLeft then
                objects.Box.TopLeft.From = boxPos
                objects.Box.TopLeft.To = boxPos + Vector2.new(cornerSize, 0)
                objects.Box.TopLeft.Visible = true
            end
            if objects.Box.Left then
                objects.Box.Left.From = boxPos
                objects.Box.Left.To = boxPos + Vector2.new(0, cornerSize)
                objects.Box.Left.Visible = true
            end
            if objects.Box.TopRight then
                objects.Box.TopRight.From = boxPos + Vector2.new(boxSize.X, 0)
                objects.Box.TopRight.To = boxPos + Vector2.new(boxSize.X - cornerSize, 0)
                objects.Box.TopRight.Visible = true
            end
            if objects.Box.Right then
                objects.Box.Right.From = boxPos + Vector2.new(boxSize.X, 0)
                objects.Box.Right.To = boxPos + Vector2.new(boxSize.X, cornerSize)
                objects.Box.Right.Visible = true
            end
            if objects.Box.BottomLeft then
                objects.Box.BottomLeft.From = boxPos + Vector2.new(0, boxSize.Y)
                objects.Box.BottomLeft.To = boxPos + Vector2.new(cornerSize, boxSize.Y)
                objects.Box.BottomLeft.Visible = true
            end
            if objects.Box.Bottom then
                objects.Box.Bottom.From = boxPos + Vector2.new(0, boxSize.Y)
                objects.Box.Bottom.To = boxPos + Vector2.new(0, boxSize.Y - cornerSize)
                objects.Box.Bottom.Visible = true
            end
            if objects.Box.BottomRight then
                objects.Box.BottomRight.From = boxPos + Vector2.new(boxSize.X, boxSize.Y)
                objects.Box.BottomRight.To = boxPos + Vector2.new(boxSize.X - cornerSize, boxSize.Y)
                objects.Box.BottomRight.Visible = true
            end
            if objects.Box.Top then
                objects.Box.Top.From = boxPos + Vector2.new(boxSize.X, boxSize.Y)
                objects.Box.Top.To = boxPos + Vector2.new(boxSize.X, boxSize.Y - cornerSize)
                objects.Box.Top.Visible = true
            end
        end
        
        for _, line in pairs(objects.Box) do
            if line and line.Visible then
                line.Color = color
                line.Thickness = Settings.BoxThickness
            end
        end
    else
        for _, line in pairs(objects.Box) do line.Visible = false end
    end
    
    -- Name ESP
    if Settings.NameESP and objects.Name then
        objects.Name.Text = player.Name .. " [" .. math.floor(distance) .. "]"
        objects.Name.Position = Vector2.new(pos.X, top.Y - 20)
        objects.Name.Color = color
        objects.Name.Size = Settings.TextSize
        objects.Name.Visible = true
    else
        if objects.Name then objects.Name.Visible = false end
    end
    
    -- Tracer ESP
    if Settings.TracerESP and objects.Tracer then
        objects.Tracer.From = GetTracerOrigin()
        objects.Tracer.To = Vector2.new(pos.X, pos.Y)
        objects.Tracer.Color = color
        objects.Tracer.Visible = true
    else
        if objects.Tracer then objects.Tracer.Visible = false end
    end
    
    -- Health ESP
    if Settings.HealthESP and objects.HealthBar then
        local health = humanoid.Health
        local maxHealth = humanoid.MaxHealth
        local healthPercent = math.max(0, math.min(1, health / maxHealth))
        
        local barHeight = screenHeight * 0.8
        local barWidth = 4
        local barPos = Vector2.new(boxPos.X - barWidth - 2, boxPos.Y + (screenHeight - barHeight)/2)
        
        if objects.HealthBar.Outline then
            objects.HealthBar.Outline.Size = Vector2.new(barWidth, barHeight)
            objects.HealthBar.Outline.Position = barPos
            objects.HealthBar.Outline.Visible = true
        end
        
        if objects.HealthBar.Fill then
            objects.HealthBar.Fill.Size = Vector2.new(barWidth - 2, barHeight * healthPercent)
            objects.HealthBar.Fill.Position = Vector2.new(barPos.X + 1, barPos.Y + barHeight * (1 - healthPercent))
            objects.HealthBar.Fill.Color = Color3.fromRGB(255 * (1 - healthPercent), 255 * healthPercent, 0)
            objects.HealthBar.Fill.Visible = true
        end
        
        if (Settings.HealthStyle == "Text" or Settings.HealthStyle == "Both") and objects.HealthBar.Text then
            objects.HealthBar.Text.Text = math.floor(health) .. "/" .. math.floor(maxHealth)
            objects.HealthBar.Text.Position = Vector2.new(boxPos.X + boxWidth/2, boxPos.Y - 5)
            objects.HealthBar.Text.Color = color
            objects.HealthBar.Text.Size = Settings.TextSize - 2
            objects.HealthBar.Text.Visible = true
        elseif objects.HealthBar.Text then
            objects.HealthBar.Text.Visible = false
        end
    else
        if objects.HealthBar then
            if objects.HealthBar.Outline then objects.HealthBar.Outline.Visible = false end
            if objects.HealthBar.Fill then objects.HealthBar.Fill.Visible = false end
            if objects.HealthBar.Text then objects.HealthBar.Text.Visible = false end
        end
    end
    
    -- Skeleton ESP
    if Settings.SkeletonESP and character then
        local skeletonColor = Settings.RainbowEnabled and Colors.Rainbow or Colors.Skeleton
        DrawSkeleton(character, objects.Skeleton, skeletonColor, Settings.SkeletonThickness)
    elseif objects.Skeleton then
        for _, line in pairs(objects.Skeleton) do
            if line then line.Visible = false end
        end
    end
    
    -- Chams
    if Settings.ChamsESP and ChamsCache[player] then
        local highlight = ChamsCache[player]
        highlight.FillColor = Settings.RainbowEnabled and Colors.Rainbow or Colors.Chams
        highlight.FillTransparency = Settings.ChamsTransparency
        highlight.Parent = character
        highlight.Enabled = true
    elseif ChamsCache[player] then
        ChamsCache[player].Enabled = false
    end
end

-- Rainbow effect
if Settings.RainbowEnabled then
    task.spawn(function()
        while task.wait(0.05) do
            Colors.Rainbow = Color3.fromHSV(tick() * Settings.RainbowSpeed % 1, 1, 1)
        end
    end)
end

-- Update loop
RunService.RenderStepped:Connect(function()
    if Settings.Enabled then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                UpdateESP(player)
            end
        end
    end
end)

-- Player events
Players.PlayerAdded:Connect(CreateESP)
Players.PlayerRemoving:Connect(RemoveESP)

-- Initialize for existing players
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        CreateESP(player)
    end
end

print("=== WA Universal ESP with Aimbot Loaded ===")
print("ðŸ“Œ Aimbot Settings (adjust at top of script):")
print("   Enabled:", AimbotSettings.Enabled)
print("   Key: Right Click (MouseButton2)")
print("   FOV:", AimbotSettings.FOV)
print("   Smoothness:", AimbotSettings.Smoothness)
print("   Prediction:", AimbotSettings.Prediction)
print("")
print("ðŸ“Œ ESP Settings:")
print("   Box ESP:", Settings.BoxESP and "ON" or "OFF")
print("   Name ESP:", Settings.NameESP and "ON" or "OFF")
print("   Skeleton ESP:", Settings.SkeletonESP and "ON" or "OFF")
